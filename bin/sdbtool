#!/usr/bin/env ruby

gem 'main',        '~> 4.2'
gem 'fattr',       '~> 2.1'
gem 'highline',    '~> 1.5'
gem 'right_aws',   '~> 1.10'
gem 'progressbar', '~> 0.0.3'
gem 'libxml-ruby', '~> 1.1'

require 'main'
require 'highline/import'
require 'fattr'
require 'right_aws'
require 'progressbar'
require 'pstore'
require 'pathname'
require 'fileutils'
require 'yaml'

module SimpleDB
  class Operation
    include Enumerable

    def initialize(sdb, method, *args)
      @sdb    = sdb
      @method = method
      @args   = args
    end

    def each
      next_token = nil
      begin
        args = @args.dup
        args << next_token
        results = @sdb.send(@method, *args)
        yield(results)
        next_token = results[:next_token]
      end while next_token
    end

  end

  class Database
    def initialize(access_key=nil, secret_key=nil, options={})
      @sdb = RightAws::SdbInterface.new(access_key, secret_key, options)
    end

    def domains
      domains_op = Operation.new(@sdb, :list_domains, nil)
      domains_op.inject([]) {|domains, results|
        domains.concat(results[:domains])
        domains
      }
    end

    def domain(domain_name)
      Domain.new(@sdb, domain_name)
    end

    def domain_exists?(domain_name)
      domains.include?(domain_name)
    end

    def create_domain(domain_name)
      @sdb.create_domain(domain_name)
      domain(domain_name)
    end

    def delete_domain(domain_name)
      @sdb.delete_domain(domain_name)
    end

    def make_dump(domain, filename)
      Dump.new(domain, filename)
    end

    def make_load(domain, filename)
      Load.new(domain, filename)
    end

    private
  end

  class Domain
    attr_reader :name

    def initialize(sdb, name)
      @sdb        = sdb
      @name       = name
      @item_names = nil
      @count      = nil
    end

    def item_names
      return @item_names if @item_names
      query = Operation.new(@sdb, :query, @name, nil, nil)
      @item_names = query.inject([]) {|names, results| 
        names.concat(results[:items])
        names
      }
    end

    def count
      return @count if @count
      op = Operation.new(@sdb, :select, "select count(*) from #{name}")
      @count = op.inject(0) {|count, results|
        count += results[:items].first["Domain"]["Count"].first.to_i
        count
      }
    end

    def items(item_names)
      names  = item_names.map{|n| "'#{n}'"}.join(', ')
      query  = "select * from #{name} where itemName() in (#{names})"
      select = Operation.new(@sdb, :select, query)
      select.inject({}) {|items, results|
        results[:items].each do |item|
          item_name  = item.keys.first
          item_value = item.values.first
          items[item_name] = item_value
        end
        items
      }
    end

    def put(item_name, attributes)
      @sdb.put_attributes(@name, item_name, attributes)
    end
  end

  class Task
    fattr :callback    => lambda{}
    fattr :chunk_size  => 100

    def initialize(status_file)
      @status_file = Pathname(status_file)
      @status = PStore.new(@status_file.to_s)
      unless @status_file.exist?
        initialize_status!(yield)
      end
      @status.transaction(false) do
        @status[$$] = {}
        @status[$$][:working_items] = []
      end
    end

    fattr :callback    => lambda{}
    fattr :chunk_size  => 100

    def session
      yield
    ensure
      release_working_items!
    end

    def incomplete_count
      @status.transaction(true) {|status|
        Array(status[:incomplete_items]).size
      }
    end

    def reserve_items!(size)
      @status.transaction(false) do |status|
        chunk = status[:incomplete_items].slice!(0,size)
        status[$$][:working_items].concat(chunk)
        chunk
      end
    end

    def finish_items!(items)
      @status.transaction(false) do |status|
        items.each do |item_name|
          status[:complete_items] << 
            status[$$][:working_items].delete(item_name)
        end
      end
    end

    def release_working_items!
      @status.transaction(false) do |status|
        items = status[$$][:working_items]
        status[:incomplete_items].concat(items)
        status[$$][:working_items].clear
      end
    end

    def report
      @status.transaction(true) do |status|
        done     = status[:complete_items].size
        not_done = status[:incomplete_items].size
        puts "Items (not done/done): #{not_done}/#{done}"
        status.roots.select{|root| root.kind_of?(Integer)}.each do |root|
          pid = root
          items = status[root][:working_items].size
          puts "Process #{pid} working on #{items} items"
        end
      end
    end

    private
    
    def initialize_status!(item_names)
      @status.transaction(false) do |status|
        status[:incomplete_items] = item_names
        status[:complete_items]   = []
      end
    end
  end

  class Dump < Task
    def initialize(domain, filename)
      @domain                   = domain
      @dump_filename            = Pathname(filename)
      super(status_filename) {
        @domain.item_names
      }
    end

    def status_filename
      Pathname(
        @dump_filename.basename(@dump_filename.extname).to_s + 
        ".simpledb_op_status")
    end

    def start!
      session do
        until (chunk = reserve_items!(chunk_size)).empty?
          items = @domain.items(chunk)
          dump_items(items)
          finish_items!(chunk)
          items.each do |item| callback.call(item) end
        end
      end
    end

    private

    def dump_items(items)
      FileUtils.touch(@dump_filename) unless @dump_filename.exist?
      file = File.new(@dump_filename.to_s)
      file.flock(File::LOCK_EX)
      @dump_filename.open('a+') do |f|
        items.each_pair do |item_name, attributes|
          YAML.dump({item_name => attributes}, f)
        end
      end
    ensure
        file.flock(File::LOCK_UN)
    end

  end

  class Load < Task
    def initialize(domain, filename)
      @domain    = domain
      @dump_filename = Pathname(filename)
      @dump_file = DumpFile.new(filename)
      super(status_filename) {
        @dump_file.item_names
      }
    end

    def status_filename
      Pathname(
        @dump_filename.basename(@dump_filename.extname).to_s + 
        "-load-#{@domain.name}.simpledb_op_status")
    end

    def start!
      session do
        chunk    = []
        reserved = Set.new
        @dump_file.each do |item_name, attributes|
          if reserved.empty?
            finish_items!(chunk)
            reserved.replace(chunk = reserve_items!(chunk_size))
            break if chunk.empty?
          end
          if reserved.include?(item_name)
            @domain.put(item_name, attributes)
            reserved.delete(item_name)
            callback.call(item_name)
          end
        end
        finish_items!(chunk)
      end
    end
  end

  class DumpFile
    include Enumerable

    def initialize(path)
      @path = Pathname(path)
    end

    def item_names
      map{|item_name, item| item_name}
    end

    def size
      inject(0){|size, item_name, item|
        size += 1
      }
    end

    def each
      @path.open('r') {|f|
        YAML.load_documents(f) {|doc|
          yield doc.keys.first, doc.values.first
        }
      }
    end
  end

end

Main do
  description 'A tool for working with Amazon SimpleDB'

  class NullObject
    def methods_missing(*args, &block)
      self
    end
  end

  def initialize
    HighLine.track_eof = false
    RightAws::RightAWSParser.xml_lib = 'libxml'
  end

  def timestamp
    Time.now.strftime('%Y%m%d%H%M')
  end

  option 'access_key' do
    description 'Amazon AWS access key'
    argument :required
    default ENV.fetch('AMAZON_ACCESS_KEY_ID') {
      ENV.fetch('AWS_ACCESS_KEY_ID')
    }
    attr
  end

  option 'secret_key' do
    description 'Amazon AWS secret key'
    argument :required
    default ENV.fetch('AMAZON_SECRET_ACCESS_KEY') {
      ENV.fetch('AWS_SECRET_ACCESS_KEY')
    }
    attr
  end

  option 'server' do
    description 'SimpleDB server hostname'
    argument :required
    default 'sdb.amazonaws.com'
  end

  option 'port' do
    description 'SimpleDB server port number'
    argument :required
    cast :int
    default 443
  end

  option 'protocol' do
    description 'SimpleDB protocol'
    argument :required
    default 'https'
  end

  option 'nil-rep' do
    description 'How to represent nil values'
    argument :required
    default '<[<[<NIL>]>]>'
  end

  option 'progress' do
    description "Show progress bar"
    cast :bool
    default true
    attr
  end

  option 'verbose' do
    description "Verbose output"
    cast :bool
    default false
    attr
  end
  
  option 'chunk-size', 'n' do
    description "The number of items to process at once"
    cast :int
    default 10
  end

  option 'log' do
    description 'File to log to'
    default 'sdbtool.log'
    attr
  end

  mixin 'domain' do
    argument 'domain' do
      description 'The SimpleDB domain to work on'
      optional
    end
  end

  fattr(:domain) { 
    params['domain'].value || choose(*db.domains) do |q|
      q.prompt = "Domain to operate on?"
    end
  }

  fattr(:db) {
    SimpleDB::Database.new(
      access_key,
      secret_key,
      :server => params['server'].value,
      :port   => params['port'].value,
      :logger => logger,
      :nil_representation => params['nil-rep'].value,
      :protocol => params['protocol'].value)
  }

  def after_parse_parameters
  end

  def before_run
    stderr log
    logger log
    unless verbose
      logger.level = ::Logger::WARN
    end
  end

  mode 'dump' do
    description 'Dump the contents of a domain to a file'

    mixin 'domain'

    argument 'file' do
      description 'File to dump into'
      optional
      attr
    end

    def run
      self.file ||= ask("Filename for this dump?") do |q|
        q.default = "#{domain}-#{timestamp}.yaml"
      end
      dump_domain = db.domain(domain)
      logger.info "Preparing to dump domain #{dump_domain.name}"
      dump = db.make_dump(dump_domain, file)
      dump.chunk_size = params['chunk-size'].value
      count = dump.incomplete_count
      logger.info "Dumping #{count} objects to #{file}"
      pbar = progress ? ProgressBar.new("dump", count,stdout) : NullObject.new
      dump.callback = lambda do |item_name|
        logger.info "Dumped #{item_name}"
        pbar.inc
      end
      dump.start!
      pbar.finish
      logger.info "Dump succeeded"
    end
  end

  mode 'count' do
    description 'Count the number of items in a domain'
    mixin 'domain'

    def run
      domain = db.domain(params['domain'].value)
      puts domain.count
    end
  end

  mode 'load' do
    description 'Load a domain from a file'

    mixin 'domain'

    argument 'file' do
      description 'The file to load from'
      attr
    end

    def run
      target_domain = if db.domain_exists?(domain)
                        db.domain(domain)
                      else
                        logger.info "Creating domain #{domain}"
                        db.create_domain(domain)
                      end
      say "About to load domain #{target_domain.name} from #{file}"
      return unless agree("Are you sure you want to continue?")
      load = db.make_load(target_domain, file)
      count = load.incomplete_count
      pbar = progress ? ProgressBar.new("load", count, stdout) : NullObject.new
      load.callback = lambda do |item_name|
        logger.info "Loaded #{item_name}"
        pbar.inc
      end
      load.start!
      pbar.finish
      logger.info "Finished loading #{file} into #{domain}"
    end

  end

  mode 'status' do
    description 'Show the status of an operation'
    
    argument 'title' do
      description 'The title of the operation'
      optional
      attr
    end

    def run
      self.title ||= choose(*Dir['*.simpledb_op_status'])
      status_file = if title =~ /\.simpledb_op_status$/
                      title
                    else
                      title + '.simpledb_op_status'
                    end
      task = SimpleDB::Task.new(status_file)
      puts task.report
    end
  end

  mode 'info' do
    description 'Show information about a dump file'

    argument 'file' do
      description 'The dump file to examine'
      attr
    end

    def run
      dump_file = SimpleDB::DumpFile.new(file)
      puts "File #{file} contains #{dump_file.size} records"
    end
  end

  mode 'delete-domain' do
    mixin 'domain'

    def run
      description 'Delete a SimpleDB domain'
      2.times do 
        agree("Are you sure you want to delete #{params['domain'].value}?") # "
      end
      db.delete_domain(params['domain'].value)
    end
  end

  def run
    help!
  end
end
